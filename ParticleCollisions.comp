#version 440

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

/*-----------------------------------------------------------------------------------------------
Description:
    Contains all info necessary for a single node of the quad tree.  It is a dumb container 
    meant for use only by ParticleQuadTree.
Creator:    John Cox (12-17-2016)
-----------------------------------------------------------------------------------------------*/
const uint MAX_PARTICLES_PER_NODE = 25;
struct ParticleQuadTreeNode
{
    // this array size MUST match the value specified on the CPU side
    uint _indicesForContainedParticles[MAX_PARTICLES_PER_NODE];
    uint _numCurrentParticles;

    int _inUse;
    int _isSubdivided;
    uint _childNodeIndexTopLeft;
    uint _childNodeIndexTopRight;
    uint _childNodeIndexBottomRight;
    uint _childNodeIndexBottomLeft;

    // left and right edges implicitly X, top and bottom implicitly Y
    float _leftEdge;
    float _topEdge;
    float _rightEdge;
    float _bottomEdge;

    uint _neighborIndexLeft;
    uint _neighborIndexTopLeft;
    uint _neighborIndexTop;
    uint _neighborIndexTopRight;
    uint _neighborIndexRight;
    uint _neighborIndexBottomRight;
    uint _neighborIndexBottom;
    uint _neighborIndexBottomLeft;
};

/*-----------------------------------------------------------------------------------------------
Description:
    Stores info about a single particle.  Must match the version on the CPU side.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
struct Particle
{
    vec4 _pos;
    vec4 _vel;
    vec4 _netForceThisFrame;
    int _collisionCountThisFrame;
    float _mass;
    float _radiusOfInfluence;
    uint _indexOfNodeThatItIsOccupying;
    int _isActive;
};

/*-----------------------------------------------------------------------------------------------
Description:
    The SSBO that contains all the ParticleQuadTreeNodes that this simulation is running.  
    Rather self-explanatory.
Creator: John Cox (1-10-2017)
-----------------------------------------------------------------------------------------------*/
layout (std430) buffer QuadTreeNodeBuffer
{
    ParticleQuadTreeNode AllNodes[];
};

/*-----------------------------------------------------------------------------------------------
Description:
    The SSBO that contains all the particles that this simulartion is running.  Rather 
    self-explanatory.
    
    Binding points are relevant only to a particular shader (that is, not to the OpenGL context 
    as a whole) and are set in the SSBO's ConfigureCompute(...) function.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
uniform uint uMaxParticles;
layout (std430) buffer ParticleBuffer
{
    Particle AllParticles[];
};


/*-----------------------------------------------------------------------------------------------
Description:
    If the distance between the two particles is close enough, then an elastic collision is 
    calculated.  Only the first particle's values are changed.  The second particle is being 
    handled by another shader invocation.  Rather than immediately change the 1st particle's 
    velocity (there may be multiple collisions in one frame), the applied force of the second on 
    the first is calculated.

    Note: For an elastic collision between two particles of equal mass, the velocities of the 
    two will be exchanged.  I could use this simplified idea for this demo, but I want to 
    eventually have the option of different masses of particles, so I will use the general 
    case elastic collision calculations (bottom of page at link).
    http://hyperphysics.phy-astr.gsu.edu/hbase/colsta.html

    for elastic collisions between two masses (ignoring rotation because these particles are 
    points), use the calculations from this article (I followed them on paper too and it 
    seems legit)
    http://www.gamasutra.com/view/feature/3015/pool_hall_lessons_fast_accurate_.php?page=3

Parameters:
    p1Index     Index into AllParticles array for particle to change.
    p2Index     Index into AllParticles array for particle to check against.
Returns:    None
Creator:    John Cox (1-25-2017)
-----------------------------------------------------------------------------------------------*/
uniform float uInverseDeltaTimeSec;
void ParticleCollisionP1WithP2(uint p1Index, uint p2Index)
{
    if (p1Index == p2Index)
    {
        // no comparison with self
        return;
    }

    // Note: ONLY change p1.  This shader is being run per particle, so the other particle will 
    // do the same calculation with this particle.
    Particle p1 = AllParticles[p1Index];
    Particle p2 = AllParticles[p2Index];

    vec4 p1ToP2 = p1._pos - p2._pos;

    // partial pythagorean theorem
    float distanceBetweenSqr = dot(p1ToP2, p1ToP2);

    float minDistanceForCollisionSqr = (p1._radiusOfInfluence + p2._radiusOfInfluence);
    minDistanceForCollisionSqr = minDistanceForCollisionSqr * minDistanceForCollisionSqr;

    if (distanceBetweenSqr > minDistanceForCollisionSqr)
    {
        // nothing to do
        return;
    }

    vec4 normalizedLineOfContact = inversesqrt(distanceBetweenSqr) * p1ToP2;

    // ??what else do I call these??
    // Note: I don't have an intuitive understanding of this calculation, but it works.  If I 
    // understood it better, then I could write better comments, but I don't, so I'm keeping it 
    // the way that I found in the gamasutra article.
    float a1 = dot(p1._vel, p1ToP2);
    float a2 = dot(p2._vel, p1ToP2);
    float fraction = (2.0f * (a1 - a2)) / (p1._mass + p2._mass);
    vec4 p1VelocityPrime = p1._vel - (fraction * p2._mass) * normalizedLineOfContact;

    // delta momentum (impulse) = force * delta time
    // therefore force = delta momentum / delta time
    vec4 p1InitialMomentum = p1._vel * p1._mass;
    vec4 p1FinalMomentum = p1VelocityPrime * p1._mass;
    vec4 p1Force = (p1FinalMomentum - p1InitialMomentum) * uInverseDeltaTimeSec;
    
    // rathering than writing back the whole particle over and over for each call to this 
    // function, just write the values that need to be written
    AllParticles[p1Index]._netForceThisFrame += p1Force;
}

/*-----------------------------------------------------------------------------------------------
Description:
    Governs the particle-particle collisions within this node and for each particle with the 
    node's neighbor, if necessary.
Parameters: 
    particleIndex   The particle that this shader is running for.
    nodeIndex       The quad tree node whose particles will be checked for collision.
Returns:    None
Creator:    John Cox (1-3-2017)
-----------------------------------------------------------------------------------------------*/
void ParticleCollisionsWithinNode(uint particleIndex, uint nodeIndex)
{
    if (nodeIndex == -1)
    {
        // Note: Whichever node gave -1 for its neighbor is on the edge of quad tree
        return;
    }

    // MUST perform this condition check or else the "node._numCurrentParticles - 1" later could 
    // result in a uint being assigned -1, which is very very big
    if (AllNodes[nodeIndex]._numCurrentParticles == 0)
    {
        return;
    }

    ParticleQuadTreeNode node = AllNodes[nodeIndex];
    for (uint pCount = 0; pCount < node._numCurrentParticles - 1; pCount++)
    {
        //AllParticles[particleIndex]._collisionCountThisFrame += 1;
        
        uint otherParticleIndex = node._indicesForContainedParticles[pCount];
        if (otherParticleIndex >= uMaxParticles)
        {
            // it may be an uninitialized -1 index
            continue;
        }

        ParticleCollisionP1WithP2(particleIndex, otherParticleIndex);
    }
}


/*-----------------------------------------------------------------------------------------------
Description:
    Starting with the provided node, ddives down through subdivisions to find the deepest leaf 
    that the particle occupies.
Parameters: 
    particleIndex       Find where this particle is living.
    startingNodeIndex   Start looking into the AllNodes[] buffer here
Returns:    
    See description.
Creator:    John Cox (1-28-2016)
-----------------------------------------------------------------------------------------------*/
uint FindLeafNode(uint particleIndex, uint startingNodeIndex)
{
    vec4 particlePosition = AllParticles[particleIndex]._pos;
    uint nodeIndex = startingNodeIndex;
    while(AllNodes[nodeIndex]._isSubdivided == 1)
    {
        // drill down to the next subdivision
        // Note: It was already determined that the particle was in the starting node, so no 
        // bounds checking is required.  I just have to figure out where it is compared to the 
        // center (the nexus of the child nodes).

        ParticleQuadTreeNode node = AllNodes[nodeIndex];

        float nodeCenterX = (node._leftEdge + node._rightEdge) * 0.5f;
        float nodeCenterY = (node._bottomEdge + node._topEdge) * 0.5f;

        // TODO: try replacing conditions with index calculation via ternary operator
        if (particlePosition.y < nodeCenterY)
        {
            // bottom
            if (particlePosition.x < nodeCenterX)
            {
                // left
                nodeIndex = node._childNodeIndexBottomLeft;
            }
            else
            {
                // right
                nodeIndex = node._childNodeIndexBottomRight;
            }
        }
        else
        {
            // top
            if (particlePosition.x < nodeCenterX)
            {
                // left
                nodeIndex = node._childNodeIndexTopLeft;
            }
            else
            {
                // right
                nodeIndex = node._childNodeIndexTopRight;
            }
        }
    }

    return nodeIndex;
}

/*-----------------------------------------------------------------------------------------------
Description:
    Determines of the particle's position is in a given node.  This is used during 
    initialization to determine which of the starting nodes the prticle occupies.  Cleans up the 
    initial "who contains this particle?" check in main(...).  
Parameters: 
    particleIndex   Find where this particle is living.
    nodeIndex       Self-explanatory.
Returns:    
    True if the particle's position occupies this node, otherwise false.
Creator:    John Cox (1-28-2016)
-----------------------------------------------------------------------------------------------*/
bool ParticleOccupiesNode(uint particleIndex, uint nodeIndex)
{
    vec4 pPos = AllParticles[particleIndex]._pos;
    bool horizontalCheck = (pPos.x >= AllNodes[nodeIndex]._leftEdge) && (pPos.x <= AllNodes[nodeIndex]._rightEdge);
    bool verticalCheck = (pPos.y >= AllNodes[nodeIndex]._bottomEdge) && (pPos.y <= AllNodes[nodeIndex]._topEdge);

    return horizontalCheck && verticalCheck;
}

/*-----------------------------------------------------------------------------------------------
Description:
    Governs the detection of particle-particle collisions with neighboring nodes to the 
    particle's starting node.
Parameters: 
    particleIndex   Find where this particle is living.
    nodeIndex       Self-explanatory.
Returns:    
    True if the particle's position occupies this node, otherwise false.
Creator:    John Cox (1-28-2016)
-----------------------------------------------------------------------------------------------*/
void ParticleCollisionsWithNeighbors(uint particleIndex, uint nodeIndex)
{
    // check against all 8 neighbors
    Particle p = AllParticles[particleIndex];
    ParticleQuadTreeNode node = AllNodes[nodeIndex];

    float x = p._pos.x;
    float y = p._pos.y;
    float r = p._radiusOfInfluence;

    // sin(45) == cos(45) == sqrt(2) / 2
    // Note: The particle's region of influence is circular.  Use a radius value modified by 
    // sin(45) to check whether the diagonal radius extends into a neighbor.
    float sqrt2Over2 = 0.70710678118f;
    float diagonalR = p._radiusOfInfluence * sqrt2Over2;

    // remember that y increases from top to bottom (y = 0 at top, y = 1 at bottom)
    bool xWithinThisNode = (x > node._leftEdge) && (x < node._rightEdge);
    bool xOverlapsLeft = x - r < node._leftEdge;
    bool xOverlapsRight = x + r > node._rightEdge;
    bool xOverlapsDiagonalLeft = x - diagonalR < node._leftEdge;
    bool xOverlapsDiagonalRight = x + diagonalR > node._leftEdge;

    bool yWithinThisNode = (y > node._topEdge) && (y < node._bottomEdge);
    bool yOverlapsTop = y - r < node._topEdge;
    bool yOverlapsBottom = y + r > node._bottomEdge;
    bool yOverlapsDiagonalTop = y - diagonalR < node._topEdge;
    bool yOverlapsDiagonalBottom = y + diagonalR > node._bottomEdge;

    // Note: If a particle is in a corner of a small particle region, it is possible for its 
    // region of influence to extend into multiple neighbors, so just use if(...) and not 
    // else if(...).
    if (xOverlapsDiagonalLeft && yOverlapsDiagonalTop)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexTopLeft);
    }

    if (xWithinThisNode && yOverlapsTop)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexTop);
    }

    if (xOverlapsDiagonalRight && yOverlapsDiagonalTop)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexTopRight);
    }

    if (xOverlapsRight && yWithinThisNode)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexRight);
    }

    if (xOverlapsDiagonalRight && yOverlapsDiagonalBottom)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexBottomRight);
    }

    if (xWithinThisNode && yOverlapsBottom)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexBottom);
    }

    if (xOverlapsDiagonalLeft && yOverlapsDiagonalBottom)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexBottomLeft);
    }

    if (xOverlapsLeft && yWithinThisNode)
    {
        ParticleCollisionsWithinNode(particleIndex, node._neighborIndexLeft);
    }
}

/*-----------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.  It governs which nodes the particle will check 
    against for collisions.
Parameters: None
Returns:    None
Creator: John Cox (1-21-2017) (adapted from CPU version, 12-17-2016)
-----------------------------------------------------------------------------------------------*/
uniform vec4 uParticleRegionCenter;
void main()
{
    uint particleIndex = gl_GlobalInvocationID.x;
    if (particleIndex >= uMaxParticles)
    {
        return;
    }

    Particle p = AllParticles[particleIndex];
    if (p._isActive == 0)
    {
        return;
    }

    // drill down from the first four nodes (initial subdivision)
    // Note: The following calculations replace a series of if-then-else statements for 
    // determining the starting node index.
    // Also Note: See enum FIRST_FOUR_NODE_INDEXES in ParticleQuadTree for the indices of the 
    // first four nodes.  These are manual reproductions of it.
    // Also Also Note: Thanks to a co-worker of mine for this algorithm.
    
    // this algorithm relies on the sign change + -> - across the axis and vice versa, so the 
    // first step is to account for non-origin particle region center.
    float particleXCentered = p._pos.x - uParticleRegionCenter.x;
    float particleYCentered = p._pos.y - uParticleRegionCenter.y;

    // convert the particle axis' positions to -1.0f/+1.0f
    float particleXUnity = abs(particleXCentered) / particleXCentered;
    float particleYUnity = abs(particleYCentered) / particleYCentered;

    // +-1.0f + 0.5f => -0.5f/+1.5f
    particleXUnity += 0.5f;
    particleYUnity += 0.5f;

    // the absolute value is +0.5/+1.5f
    particleXUnity = abs(particleXUnity);
    particleYUnity = abs(particleYUnity);

    // jam the values into an integer to get 0/1
    // Note: If the particle X is left of 0, then the previous calculations will result in particleXUnity = +0.5.  Putting that into an integer will result in a 0.  I am trying to recreate a boolean value, so if particleXUnity is integer-ified, then it will be 0 and therefore false.  So a particle X is left of 0, then it will simplified to integer 0 ("false"), which means "is right".  Similarly, a particle Y below zero will be simplified to integer 0 (false), which means "is top".
    uint isRight = int(particleXUnity);
    uint isTop = int(particleYUnity);

    // use the integer values as true/false substitutes
    // Note: The result of these multiplications is that every entry is 0 or non-0 except for the top left, which is already index 0.  These values are summed together later, so the only way to get the top left node's index is for all others to be 0.  This is ok.
    uint isTopLeftIndex = 0 * ((1 - isRight) * isTop);
    uint isTopRightIndex = 1 * (isRight * isTop);
    uint isBottomLeftIndex = 2 * ((1 - isRight) * (1 - isTop));
    uint isBottomRightIndex = 3 * (isRight * (1 - isTop));




//    uint isLeft = (p._pos.x < uParticleRegionCenter.x) ? 1 : 0;
//    uint isTop = (p._pos.y > uParticleRegionCenter.y) ? 1 : 0;
//    uint isTopLeftIndex = 0 * (isLeft * isTop);
//    uint isTopRightIndex = 1 * ((1 - isLeft) * isTop);
//    uint isBottomLeftIndex = 2 * (isLeft * (1 - isTop));
//    uint isBottomRightIndex = 3 * ((1 - isLeft) * (1 - isTop));

    // only one of the first four indices will be non-zero
    uint startingNodeIndex = 
        isTopLeftIndex +
        isTopRightIndex + 
        isBottomLeftIndex + 
        isBottomRightIndex;

//    if (startingNodeIndex == 3)
//    {
//        AllParticles[particleIndex]._netForceThisFrame.y = -0.2f;
//    }


//    uint startingNodeIndex =-1;
//    if (ParticleOccupiesNode(particleIndex, 0))
//    {
//        startingNodeIndex = 0;
//    }
//    else if (ParticleOccupiesNode(particleIndex, 1))
//    {
//        startingNodeIndex = 1;
//    }
//    else if (ParticleOccupiesNode(particleIndex, 2))
//    {
//        startingNodeIndex = 2;
//    }
//    else if (ParticleOccupiesNode(particleIndex, 3))
//    {
//        startingNodeIndex = 3;
//    }
//    else
//    {
//        // the particle is not within the first subdivision; something has gone terribly wrong
//    }

    uint leafNodeIndex = FindLeafNode(particleIndex, startingNodeIndex);

//    float f = 0.8f;
//    int i = int(f);
//    if (i == 1)
//    {
//        AllParticles[particleIndex]._netForceThisFrame.x = -0.01f;
//    }

    ParticleCollisionsWithinNode(particleIndex, leafNodeIndex);
//    ParticleCollisionsWithNeighbors(particleIndex, leafNodeIndex);



}

